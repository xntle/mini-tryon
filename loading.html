<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Responsive Rotating Grid Loader</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #grid {
    display: grid;
    width: 90vmin;
    height: 90vmin; /* Make grid square and responsive */
    gap: 1vmin;
    /* Will set grid-template-columns/rows dynamically */
  }

  .cell {
    background: #444;
    border-radius: 6px;
    aspect-ratio: 1 / 1; /* Keep squares */
    transition: transform 0.5s ease, background-color 0.5s ease;
  }

  .rotating {
    transform: rotate(360deg);
    background: #00ff99;
  }
</style>
</head>
<body>

<div id="grid"></div>

<script>
  const grid = document.getElementById('grid');

  function createGrid() {
    // Clear any existing cells
    grid.innerHTML = '';

    // Calculate number of columns/rows based on grid width and minimum cell size
    const gridSize = grid.clientWidth; // since width === height
    const minCellSize = 40; // px minimum size per cell
    const gap = parseFloat(getComputedStyle(grid).gap);

    const cols = Math.floor(gridSize / (minCellSize + gap));
    const rows = cols; // square grid

    // Set grid template dynamically
    grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

    const totalCells = cols * rows;

    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      grid.appendChild(cell);
    }
  }

  createGrid();

  let rotatingIndexes = new Set();

  function rotateRandomCells() {
    const cells = grid.children;
    const totalCells = cells.length;
    let newRotations = [];

    // Pick 3 random cells that are not already rotating
    while (newRotations.length < 3 && newRotations.length < totalCells) {
      const idx = Math.floor(Math.random() * totalCells);
      if (!rotatingIndexes.has(idx)) {
        rotatingIndexes.add(idx);
        newRotations.push(idx);
      }
    }

    newRotations.forEach((index) => {
      const cell = cells[index];
      cell.classList.add('rotating');

      // Remove rotating after animation duration
      setTimeout(() => {
        cell.classList.remove('rotating');
        rotatingIndexes.delete(index);
      }, 500);
    });
  }

  setInterval(rotateRandomCells, 400);

  // Recreate grid on resize
  window.addEventListener('resize', () => {
    createGrid();
  });
</script>

</body>
</html>
